<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `13_memory` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, 13_memory">

    <title>13_memory - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
    
    <link rel="stylesheet" type="text/css" href="../dark.css">
    <link rel="stylesheet" type="text/css" href="../main.css" id="themeStyle">
    <script src="../storage.js"></script>
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Crate 13_memory</p><div class="sidebar-elems"><p class='location'></p><script>window.sidebarCurrent = {name: '13_memory', ty: 'mod', relpath: '../'};</script></div>
    </nav>

    <div class="theme-picker">
        <button id="theme-picker" aria-label="Pick another theme!">
            <img src="../brush.svg" width="18" alt="Pick another theme!">
        </button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>13_memory</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/13_memory/lib.rs.html#1-252' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><h2 id="13-memory" class="section-header"><a href="#13-memory">13 Memory</a></h2>
<p>Welcome to thirteenth step of this Rust workshop.</p>
<p>This step focuses on defining memory guarantees.</p>
<h2 id="heap-allocation" class="section-header"><a href="#heap-allocation">Heap allocation</a></h2>
<p>Memory allocation is organized in two different ways: <strong>heap</strong> &amp; <strong>stack</strong>.</p>
<p><strong>Stack</strong> is a per-thread allocated space. Each function generate a new stack frame then, when
completed, frame is thrown away with all allocated memory. That is fast and efficient way to
free memory. That's why it's default Rust behaviour.</p>
<p>On the other side, <strong>heap</strong> has no lifetime bounds (except for process itself) and has no
particular organisation. These characteristics makes allocated memory to grow, to be shared
between threads and to survive stack frames.</p>
<p>Primary way to declare a heap allocated variable is to use a <code>Box</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">on_heap</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="number">1</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20on_heap%20%3D%20Box%3A%3Anew(1)%3B%0A%7D">Run</a></pre>
<p><code>Box</code> acts exactly as a stack allocated data and still preserve ownership, borrowing and
lifetime: can be read-only shared, write-exclusive shared and freed when no more in use:</p>

<pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyType</span> { <span class="comment">/* ... */</span> }
<span class="kw">impl</span> <span class="ident">MyType</span> {
    <span class="kw">fn</span> <span class="ident">own</span>(<span class="self">self</span>) { <span class="comment">/* ... */</span> }
    <span class="kw">fn</span> <span class="ident">borrow</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { <span class="comment">/* ... */</span> }
    <span class="kw">fn</span> <span class="ident">mutate</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) { <span class="comment">/* ... */</span> }
}

<span class="kw">fn</span> <span class="ident">own</span>() {
    <span class="kw">let</span> <span class="ident">variable</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">MyType</span> { <span class="comment">/* ... */</span> });
    <span class="ident">variable</span>.<span class="ident">own</span>(); <span class="comment">// Ok</span>
    <span class="comment">// Compilation error</span>
    <span class="comment">// variable.method();</span>
}

<span class="kw">fn</span> <span class="ident">borrow</span>() {
    <span class="kw">let</span> <span class="ident">variable</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">MyType</span> { <span class="comment">/* ... */</span> });
    <span class="ident">variable</span>.<span class="ident">borrow</span>();
    <span class="ident">variable</span>.<span class="ident">borrow</span>();
}

<span class="kw">fn</span> <span class="ident">mutate</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">variable</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">MyType</span> { <span class="comment">/* ... */</span> });
    <span class="kw">let</span> <span class="ident">borrowed</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">variable</span>;
    <span class="ident">borrowed</span>.<span class="ident">mutate</span>();
    <span class="comment">// Compilation error</span>
    <span class="comment">//variable.mutate();</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Astruct%20MyType%20%7B%20%2F*%20...%20*%2F%20%7D%0Aimpl%20MyType%20%7B%0A%20%20%20%20fn%20own(self)%20%7B%20%2F*%20...%20*%2F%20%7D%0A%20%20%20%20fn%20borrow(%26self)%20%7B%20%2F*%20...%20*%2F%20%7D%0A%20%20%20%20fn%20mutate(%26mut%20self)%20%7B%20%2F*%20...%20*%2F%20%7D%0A%7D%0A%0Afn%20own()%20%7B%0A%20%20%20%20let%20variable%20%3D%20Box%3A%3Anew(MyType%20%7B%20%2F*%20...%20*%2F%20%7D)%3B%0A%20%20%20%20variable.own()%3B%20%2F%2F%20Ok%0A%20%20%20%20%2F%2F%20Compilation%20error%0A%20%20%20%20%2F%2F%20variable.method()%3B%0A%7D%0A%0Afn%20borrow()%20%7B%0A%20%20%20%20let%20variable%20%3D%20Box%3A%3Anew(MyType%20%7B%20%2F*%20...%20*%2F%20%7D)%3B%0A%20%20%20%20variable.borrow()%3B%0A%20%20%20%20variable.borrow()%3B%0A%7D%0A%0Afn%20mutate()%20%7B%0A%20%20%20%20let%20mut%20variable%20%3D%20Box%3A%3Anew(MyType%20%7B%20%2F*%20...%20*%2F%20%7D)%3B%0A%20%20%20%20let%20borrowed%20%3D%20%26mut%20variable%3B%0A%20%20%20%20borrowed.mutate()%3B%0A%20%20%20%20%2F%2F%20Compilation%20error%0A%20%20%20%20%2F%2Fvariable.mutate()%3B%0A%7D%0A%7D">Run</a></pre>
<p><code>Box</code> are generally used to declare recursive types:</p>

<pre class="rust rust-example-rendered">
<span class="kw">enum</span> <span class="ident">List</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="ident">Cons</span>(<span class="ident">T</span>, <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">List</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;&gt;</span>),
    <span class="ident">Nil</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aenum%20List%3CT%3E%20%7B%0A%20%20%20%20Cons(T%2C%20Box%3CList%3CT%3E%3E)%2C%0A%20%20%20%20Nil%2C%0A%7D%0A%7D">Run</a></pre>
<h2 id="reference-counter" class="section-header"><a href="#reference-counter">Reference counter</a></h2>
<p>Sometimes you need to share read-only data between many &quot;owner&quot; but without clear one. In this
case <code>std::rc::Rc</code> helps you to share pieces of data in read-only. It's closed to a borrow, but
without pre-defined lifetime.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> {
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">Person</span>::<span class="ident">new</span>(<span class="string">&quot;Bob&quot;</span>));
    <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">rc</span>.<span class="ident">clone</span>(), <span class="ident">rc</span>.<span class="ident">clone</span>(), <span class="ident">rc</span>.<span class="ident">clone</span>(), <span class="ident">rc</span>.<span class="ident">clone</span>()]
};

<span class="ident">list</span>.<span class="ident">remove</span>(<span class="number">0</span>);
<span class="ident">list</span>.<span class="ident">remove</span>(<span class="number">0</span>);
<span class="ident">list</span>.<span class="ident">remove</span>(<span class="number">0</span>);
<span class="ident">list</span>.<span class="ident">remove</span>(<span class="number">0</span>); <span class="comment">// Deallocated after this line</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Astruct%20Person%20%7B%20name%3A%20String%20%7D%0Aimpl%20Person%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hello%20%7B%7D%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20Person%20%7B%20name%3A%20String%3A%3Afrom(name)%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Drop%20for%20Person%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Goodbye%20%7B%7D%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Ause%20std%3A%3Arc%3A%3ARc%3B%0Alet%20mut%20list%20%3D%20%7B%0A%20%20%20%20let%20rc%20%3D%20Rc%3A%3Anew(Person%3A%3Anew(%22Bob%22))%3B%0A%20%20%20%20vec!%5Brc.clone()%2C%20rc.clone()%2C%20rc.clone()%2C%20rc.clone()%5D%0A%7D%3B%0A%0Alist.remove(0)%3B%0Alist.remove(0)%3B%0Alist.remove(0)%3B%0Alist.remove(0)%3B%20%2F%2F%20Deallocated%20after%20this%20line%0A%0Aprintln!(%22**%20END%20**%22)%3B%0A%7D">Run</a></pre>
<p>It may happen two elements into a struct are (directly or not) counting reference mutually ; thus, memory can't be freed as counter can never rich zero due to circular references. For this purpose, <code>std::rc::Weak</code> must be used.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::{<span class="ident">Rc</span>, <span class="ident">Weak</span>};
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="number">1</span>);

<span class="kw">let</span> <span class="ident">weak</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">downgrade</span>(<span class="kw-2">&amp;</span><span class="ident">value</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;weak: {:?}&quot;</span>, <span class="ident">weak</span>.<span class="ident">upgrade</span>()); <span class="comment">// Some(1)</span>

<span class="ident">drop</span>(<span class="ident">value</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;weak: {:?}&quot;</span>, <span class="ident">weak</span>.<span class="ident">upgrade</span>()); <span class="comment">// None</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Arc%3A%3A%7BRc%2C%20Weak%7D%3B%0Alet%20value%20%3D%20Rc%3A%3Anew(1)%3B%0A%0Alet%20weak%20%3D%20Rc%3A%3Adowngrade(%26value)%3B%0Aprintln!(%22weak%3A%20%7B%3A%3F%7D%22%2C%20weak.upgrade())%3B%20%2F%2F%20Some(1)%0A%0Adrop(value)%3B%0Aprintln!(%22weak%3A%20%7B%3A%3F%7D%22%2C%20weak.upgrade())%3B%20%2F%2F%20None%0A%7D">Run</a></pre>
<h1 id="interior-mutability" class="section-header"><a href="#interior-mutability">Interior mutability</a></h1>
<p>By default, Rust applies <em>inherited mutability</em>, meaning mutability is declared at usage and propagates to all pieces of the data.
Some constructs in Rust offers <em>interior mutability</em>, meaning data can mutate while not explicitly declared as <code>mut</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Owner</span> {
    <span class="ident">owned</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">Owner</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">value</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">Owner</span> { <span class="ident">owned</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="ident">value</span>) }
    }
    <span class="kw">fn</span> <span class="ident">set</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">newvalue</span>: <span class="ident">i32</span>) {
        <span class="self">self</span>.<span class="ident">owned</span>.<span class="ident">set</span>(<span class="ident">newvalue</span>)
    }
}

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">Owner</span>::<span class="ident">new</span>(<span class="number">0</span>);
<span class="ident">data</span>.<span class="ident">set</span>(<span class="number">1</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Acell%3A%3ACell%3B%0A%23%5Bderive(Debug)%5D%0Astruct%20Owner%20%7B%0A%20%20%20%20owned%3A%20Cell%3Ci32%3E%2C%0A%7D%0Aimpl%20Owner%20%7B%0A%20%20%20%20fn%20new(value%3A%20i32)%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20Owner%20%7B%20owned%3A%20Cell%3A%3Anew(value)%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20fn%20set(%26self%2C%20newvalue%3A%20i32)%20%7B%0A%20%20%20%20%20%20%20%20self.owned.set(newvalue)%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20data%20%3D%20Owner%3A%3Anew(0)%3B%0Adata.set(1)%3B%0A%7D">Run</a></pre>
<h1 id="runtime-checked-borrowing" class="section-header"><a href="#runtime-checked-borrowing">Runtime-checked borrowing</a></h1>
<p>It may happens that borrowing rules can't be enforced at compile time. Then use <code>std::cell::RefCell</code> that will <code>panic!</code> when violating invariants. Following examples compiles but panic at runtime.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">RefCell</span>;
<span class="kw">let</span> <span class="ident">cell</span> <span class="op">=</span> <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="number">0</span>);

<span class="kw">let</span> <span class="ident">read0</span> <span class="op">=</span> <span class="ident">cell</span>.<span class="ident">borrow</span>(); <span class="comment">// Ok</span>
<span class="kw">let</span> <span class="ident">read1</span> <span class="op">=</span> <span class="ident">cell</span>.<span class="ident">borrow</span>(); <span class="comment">// Ok</span>
<span class="ident">cell</span>.<span class="ident">borrow_mut</span>(); <span class="comment">// Panic</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Acell%3A%3ARefCell%3B%0Alet%20cell%20%3D%20RefCell%3A%3Anew(0)%3B%0A%0Alet%20read0%20%3D%20cell.borrow()%3B%20%2F%2F%20Ok%0Alet%20read1%20%3D%20cell.borrow()%3B%20%2F%2F%20Ok%0Acell.borrow_mut()%3B%20%2F%2F%20Panic%0A%7D">Run</a></pre>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">write</span> <span class="op">=</span> <span class="ident">cell</span>.<span class="ident">borrow_mut</span>(); <span class="comment">// Ok</span>
<span class="ident">cell</span>.<span class="ident">borrow</span>(); <span class="comment">// Panic</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20cell%20%3D%20std%3A%3Acell%3A%3ARefCell%3A%3Anew(0)%3B%0Alet%20write%20%3D%20cell.borrow_mut()%3B%20%2F%2F%20Ok%0Acell.borrow()%3B%20%2F%2F%20Panic%0A%7D">Run</a></pre>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">write</span> <span class="op">=</span> <span class="ident">cell</span>.<span class="ident">borrow_mut</span>(); <span class="comment">// Ok</span>
<span class="ident">cell</span>.<span class="ident">borrow_mut</span>(); <span class="comment">// Panic</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20cell%20%3D%20std%3A%3Acell%3A%3ARefCell%3A%3Anew(0)%3B%0Alet%20write%20%3D%20cell.borrow_mut()%3B%20%2F%2F%20Ok%0Acell.borrow_mut()%3B%20%2F%2F%20Panic%0A%7D">Run</a></pre>
<h1 id="idiomatic-rust" class="section-header"><a href="#idiomatic-rust">Idiomatic Rust</a></h1>
<p>That's lot of stuff and idiomatic Rust requires to combine them all to provide guarantees you need.
For example, to share replaceable value:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">0</span>));

<span class="kw">let</span> <span class="ident">d0</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">clone</span>();
<span class="ident">drop</span>(<span class="ident">data</span>);

<span class="kw">let</span> <span class="ident">d1</span> <span class="op">=</span> <span class="ident">d0</span>.<span class="ident">clone</span>();
<span class="ident">d0</span>.<span class="ident">set</span>(<span class="number">1</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0Ause%20std%3A%3Acell%3A%3ACell%3B%0A%0Alet%20data%3A%20Rc%3CCell%3Ci32%3E%3E%20%3D%20Rc%3A%3Anew(Cell%3A%3Anew(0))%3B%0A%0Alet%20d0%20%3D%20data.clone()%3B%0Adrop(data)%3B%0A%0Alet%20d1%20%3D%20d0.clone()%3B%0Ad0.set(1)%3B%0Aprintln!(%22data%3A%20%7B%7D%22%2C%20d1.get())%3B%0A%7D">Run</a></pre>
<p>However, to extract value (<code>.get()</code>), type must be <code>Copy</code> and need to replace entire data.</p>
<p>Thus, to share updatable value:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foobar</span> {
    <span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
    <span class="ident">bar</span>: <span class="ident">i32</span>,
}

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">Foobar</span> { <span class="ident">foo</span>: <span class="string">&quot;The question&quot;</span>, <span class="ident">bar</span>: <span class="number">42</span> }));

<span class="kw">let</span> <span class="ident">d0</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">clone</span>();
<span class="ident">drop</span>(<span class="ident">data</span>);

<span class="kw">let</span> <span class="ident">d1</span> <span class="op">=</span> <span class="ident">d0</span>.<span class="ident">clone</span>();
<span class="ident">d0</span>.<span class="ident">borrow_mut</span>().<span class="ident">foo</span> <span class="op">=</span> <span class="string">&quot;The answer&quot;</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0Ause%20std%3A%3Acell%3A%3ARefCell%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20Foobar%20%7B%0A%20%20%20%20foo%3A%20%26'static%20str%2C%0A%20%20%20%20bar%3A%20i32%2C%0A%7D%0A%0Alet%20data%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Foobar%20%7B%20foo%3A%20%22The%20question%22%2C%20bar%3A%2042%20%7D))%3B%0A%0Alet%20d0%20%3D%20data.clone()%3B%0Adrop(data)%3B%0A%0Alet%20d1%20%3D%20d0.clone()%3B%0Ad0.borrow_mut().foo%20%3D%20%22The%20answer%22%3B%0Aprintln!(%22data%3A%20%7B%3A%3F%7D%22%2C%20d1.borrow())%3B%0A%7D">Run</a></pre>
<p>Finally, you can rely on <a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/newtype.md"><em>newtype</em> pattern</a> to provide cleaner API with no runtime overhead through zero-cost abstraction provided by Rust.</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">foobar</span> {

    <span class="kw">struct</span> <span class="ident">InternalFoobar</span> {
        <span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
        <span class="ident">bar</span>: <span class="ident">i32</span>,
    }

    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">RefCell</span>;
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Foobar</span>(<span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">InternalFoobar</span><span class="op">&gt;&gt;</span>,);

    <span class="kw">impl</span> <span class="ident">Foobar</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>, <span class="ident">bar</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
            <span class="ident">Foobar</span>(<span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">InternalFoobar</span> { <span class="ident">foo</span>, <span class="ident">bar</span> })))
        }

        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_foo</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>) {
            <span class="self">self</span>.<span class="number">0</span>.<span class="ident">borrow_mut</span>().<span class="ident">foo</span> <span class="op">=</span> <span class="ident">foo</span>;
        }
    }
}

<span class="kw">let</span> <span class="ident">foobar</span> <span class="op">=</span> <span class="ident">foobar</span>::<span class="ident">Foobar</span>::<span class="ident">new</span>(<span class="string">&quot;The question&quot;</span>, <span class="number">42</span>);
<span class="ident">foobar</span>.<span class="ident">set_foo</span>(<span class="string">&quot;The answer&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Amod%20foobar%20%7B%0A%0A%20%20%20%20struct%20InternalFoobar%20%7B%0A%20%20%20%20%20%20%20%20foo%3A%20%26'static%20str%2C%0A%20%20%20%20%20%20%20%20bar%3A%20i32%2C%0A%20%20%20%20%7D%0A%0A%20%20%20%20use%20std%3A%3Arc%3A%3ARc%3B%0A%20%20%20%20use%20std%3A%3Acell%3A%3ARefCell%3B%0A%20%20%20%20pub%20struct%20Foobar(Rc%3CRefCell%3CInternalFoobar%3E%3E%2C)%3B%0A%0A%20%20%20%20impl%20Foobar%20%7B%0A%20%20%20%20%20%20%20%20pub%20fn%20new(foo%3A%20%26'static%20str%2C%20bar%3A%20i32)%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Foobar(Rc%3A%3Anew(RefCell%3A%3Anew(InternalFoobar%20%7B%20foo%2C%20bar%20%7D)))%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20pub%20fn%20set_foo(%26self%2C%20foo%3A%20%26'static%20str)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.0.borrow_mut().foo%20%3D%20foo%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20use%20std%3A%3Afmt%3A%3A%7BDebug%2C%20Formatter%2C%20Error%7D%3B%0A%20%20%20%20impl%20Debug%20for%20Foobar%20%7B%0A%20%20%20%20%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20Formatter)%20-%3E%20Result%3C()%2C%20Error%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20this%20%3D%20self.0.borrow()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20write!(f%2C%20%22Foobar%20%7B%7B%20foo%3A%20%7B%3A%3F%7D%2C%20bar%3A%20%7B%3A%3F%7D%20%7D%7D%22%2C%20this.foo%2C%20this.bar)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20foobar%20%3D%20foobar%3A%3AFoobar%3A%3Anew(%22The%20question%22%2C%2042)%3B%0Afoobar.set_foo(%22The%20answer%22)%3B%0Aprintln!(%22Result%3A%20%7B%3A%3F%7D%22%2C%20foobar)%3B%0A%7D">Run</a></pre>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt><kbd>?</kbd></dt>
                    <dd>Show this help dialog</dd>
                    <dt><kbd>S</kbd></dt>
                    <dd>Focus the search field</dd>
                    <dt><kbd>↑</kbd></dt>
                    <dd>Move up in search results</dd>
                    <dt><kbd>↓</kbd></dt>
                    <dd>Move down in search results</dd>
                    <dt><kbd>↹</kbd></dt>
                    <dd>Switch tab</dd>
                    <dt><kbd>&#9166;</kbd></dt>
                    <dd>Go to active search result</dd>
                    <dt><kbd>+</kbd></dt>
                    <dd>Expand all sections</dd>
                    <dt><kbd>-</kbd></dt>
                    <dd>Collapse all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "13_memory";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>